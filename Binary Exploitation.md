# Binary Exploitation

## hijacking

### Challenge
Getting root access can allow you to read the flag. Luckily there is a python file that you might like to play with.  
Through Social engineering, we've got the credentials to use on the server. SSH is running on the server.  
saturn.picoctf.net 52835  
Username: picoctf  
Password: soPcpnfyC5  

### Solving
For this challenge we need to connect to the remote server specified from the terminal (FYI we can use PicoCTF's Webshell for this). The command for that is:
```
devt0nes-picoctf@webshell:~$ ssh picoctf@saturn.picoctf.net -p 52835
```
After which we're prompted to enter the password, which is `soPcpnfyC5`. This will successfully connect us to the server.  

Now first things first, we view all the files present in the directory we are.
```
picoctf@challenge:~$ ls
picoctf@challenge:~$ ls -a
.  ..  .bash_history  .bash_logout  .bashrc  .cache  .profile  .server.py
```

Here `.server.py` is of interest to us, as the statement mentions a python file.  
Trying to execute the file directly results in:
```
picoctf@challenge:~$ ./.server.py
-bash: ./.server.py: Permission denied
picoctf@challenge:~$ sudo ./.server.py
[sudo] password for picoctf:
sudo: ./.server.py: command not found
```
Since the file isn't executable, we can try modifying it to make it so but that doesn't work either:
```
picoctf@challenge:~$ chmod +x .server.py
chmod: changing permissions of '.server.py': Operation not permitted
picoctf@challenge:~$ sudo chmod +x .server.py
[sudo] password for picoctf:
Sorry, user picoctf is not allowed to execute '/usr/bin/chmod +x .server.py' as root on challenge.
```
Running it as a python file itself gives us the following:
```
picoctf@challenge:~$ python3 .server.py
sh: 1: ping: not found
Traceback (most recent call last):
  File ".server.py", line 7, in <module>
    host_info = socket.gethostbyaddr(ip)
socket.gaierror: [Errno -5] No address associated with hostname
```
And we can read the python file using `cat` to see what's actually executing.
```python
import base64
import os
import socket
ip = 'picoctf.org'
response = os.system("ping -c 1 " + ip)
#saving ping details to a variable
host_info = socket.gethostbyaddr(ip)
#getting IP from a domaine
host_info_to_str = str(host_info[2])
host_info = base64.b64encode(host_info_to_str.encode('ascii'))
print("Hello, this is a part of information gathering",'Host: ', host_info)
```

Now at this point I saved the file locally using the command `scp -P 52835 picoctf@saturn.picoctf.net:.server.py .` and ran the program, which gave the following output:
```
PING picoctf.org (13.226.120.95) 56(84) bytes of data.
64 bytes from server-13-226-120-95.hkg62.r.cloudfront.net (13.226.120.95): icmp_seq=1 ttl=244 time=102 ms

--- picoctf.org ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 101.662/101.662/101.662/0.000 ms
Hello, this is a part of information gathering Host:  b'WycxMy4yMjYuMTIwLjEyJ10='
```
Here `WycxMy4yMjYuMTIwLjEyJ10=` in the last line in base64 encoded and decoding it gives us `['13.226.120.12']` which is an IP address.  
I spent a lot of time trying to connect to the IP address, including using:
1. **telnet**, **netcat** and **ftp** to try and connect to the address
2. **nmap** to scan for open ports and services running (`nmap -p-` and `nmap -sV`)
3. [ipinfo.io](https://ipinfo.io/) to see where the address is located

However I realized that messing with the python file locally was a dead end because the flag would be found on and through the remote server only.




[//]: # (REFERENCES:)
[//]: # (https://www.wikihow.com/Become-Root-in-Linux#:~:text=You%20can%20unlock%20the%20root,T%20to%20start%20the%20terminal.&text=2-,Type,root%20and%20press%20%E2%86%B5%20Enter%20.)
[//]: # (https://blog.lumen.com/8-ways-to-succeed-in-your-first-capture-the-flag-ctf/)
[//]: # (https://medium.com/@CYberVIaz/pico-ctf-python-wrangling-writeups-900ee1bc25a6)
[//]: # (https://delinea.com/blog/linux-privilege-escalation)

[//]: # (For editing a Python file, use: `nano`, `vim`)